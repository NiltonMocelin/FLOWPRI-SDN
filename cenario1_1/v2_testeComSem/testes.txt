-- Refazendo tudo

#coletar tempo no python
import time
millis = round(time.monotonic() * 1000)

-- OBS: nao pode pegar o tempo pelo tcpdump se usar relogio monotonico

#       teste de overhead:

-- separar os tempos de processamento (criar regras ) e tempo de troca de contratos.


#### Controlador modificado para medir TEMPO (c1_v2_semPrints.py e c2_v2_semPrints.py) - removido todos os prints, menos os do tempo

# comando watch monitora um comando com saidas a cada 2s
# comando time retorna o tempo percorrido entre a chamada e o retorno de um comando (pouco preciso)

T1 - Verificar o tempo que leva para estabelecer um contrato e o tempo que leva para um controlador apartir de uma conexao tcp: receber um contrato, anunciar (icmp 15) + controlador responder (icmp 16) + controlador receber o contrato:

- medir os tcpdump de cada interface + medir tempo no controlador
- medindo o tempo quando aceita a conexao tcp (socket que escuta contratos de hosts), apos receber o contrato e criar as regras. 

- [corrigido] infelizmente a comunicacao entre os controladores ocorre por fora do mininet. Mas a comunicacao entre controladores e hosts ocorre dentro do mininet.
- [feito] posso medir o tempo de envio de um contrato entre c1 e c2, mas por meio de uma modificacao, usar o estabelecimento de contrato entre h1 e c2, que eh a mesma funcao basicamente host-controlador == controlador-controlador.
- [feito] posso inventar um ip que nao seja reconhecido como localhost
- [feito] o problema esta nas rotas provavelmente tabela route, 10.123.123.1 deve estar enviando para uma interface errada

- (faz sentido) medir tempo quando recebe um icmp 15 (que eh quando tbm envia o icmp 16), quando recebe um icmp 16.
--:> dividir em dois tempos: (t1) tempo de comunicacao + (t2) tempo de processamento

* t1 - tempo de comunicacao entre h1-c1 + tempo de comunicacao c1-c2
    [h1-c1]:
        - h1 python contrato_cli_v2.py 10.10.10.1 172.16.10.1 172.16.10.4 1000 1 1
        - medir o tempo de saida do primeiro pacote de h1
        - medir o tempo quando c1 recebe o contrato de h1
    
    [c1]
        - medir o tempo de processamento: para enviar as mensagens de criacao de regras nos switches e alocarGBAM
    
    [c1-c2]
        - medir o tempo que o icmp 15 sai de c1
        - medir o tempo que c2 recebe icmp 15
        - c2 nao tem muito processamento aqui - tenho que rever o que ele faz
        - medir o tempo que c2 envia icmp 16
        - medir o tempo que c1 recebe icmp 16
        - medir o tempo para que c1 procure o contrato
        - medir o tempo que c1 envia o contrato
        - medir o tempo para que c2 receba o contrato
        - medir o tempo de processamento: para c2 enviar as mensagens de criacao de regras nos switches e alocarGBAM

--- falar a verdade esse teste ja engloba tudo

.   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . 

T2 - X - Verificar o tempo que leva entre emitir um contrato e conseguir enviar pacotes (criar um contrato e enviar um ping -c 1): 
- medir o tempo desde definir um contrato at√© as regras estarem ativas em um switch
- usar o time python contrato_cli_c1.py && ping -c 1 ...
ex: time (echo "a"; echo "b")

T4 - Verificar o tempo que leva para encaminhar o primeiro pacote de um fluxo -  ja tenho o contrato + as regras expiraram + enviar um ping -c 1
- medir com time
- observar os tcpdump dos hosts origem e destino


T3 - Verificar o tempo que leva para encaminhar o segundo pacote de um fluxo:
- observar os tcpdump dos hosts origem e destino


T5 - Verificar o tempo que um fluxo leva para entregar 10 pacotes em um cenario com o framework, estabelecendo o contrato
- observar os tcpdump dos hosts origem e destino
- usar o time python contrato_cli_c1.py && ping -c 10 ...


T6 - Verificar o tempo que um fluxo leva para entregar 10 pacotes em um cenario com o framework, com o contrato pre-estabelecido
- observar os tcpdump dos hosts origem e destino
- usar o time ping -c 10 ...


T7 - Verificar o tempo que um fluxo leva para entregar 10 pacotes em um cenario sem o framework, roteador normal
- observar os tcpdump dos hosts origem e destino
- usar o time ping -c 10 ...

T8 - Verificar se a largura de banda acordada eh a mesma entregue - com um fluxo que nao empresta e com um fluxo que empresta:
- verificar com iperf

T8 - Verificar o impacto de um switch sem suporte ao framework, sem congestionamento, entre dois dominios com suporte:
- banda acordada eh a mesma recebida: - verificar com iperf

- tempo de estabelecer contrato: aumenta? (mas agr tem 3 switches e antes so teria 2)


T9 - Verificar o impacto de um switch sem suporte ao framework, com congestionamento, entre dois dominios com suporte:
- observar os tcpdump dos hosts origem e destino
- usar time

T10 - Verificar o tempo entre o controlador criar uma regra de fluxo e o switch ativa-la